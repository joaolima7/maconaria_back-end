// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: timeline_queries.sql

package db

import (
	"context"
	"database/sql"
)

const createTimeline = `-- name: CreateTimeline :execresult
INSERT INTO timelines (id, period, pdf_data, is_highlight)
VALUES (?, ?, ?, ?)
`

type CreateTimelineParams struct {
	ID          string
	Period      string
	PdfData     []byte
	IsHighlight bool
}

func (q *Queries) CreateTimeline(ctx context.Context, arg CreateTimelineParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTimeline,
		arg.ID,
		arg.Period,
		arg.PdfData,
		arg.IsHighlight,
	)
}

const deleteTimeline = `-- name: DeleteTimeline :exec
DELETE FROM timelines WHERE id = ?
`

func (q *Queries) DeleteTimeline(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteTimeline, id)
	return err
}

const getAllTimelines = `-- name: GetAllTimelines :many
SELECT id, period, pdf_data, is_highlight, created_at, updated_at
FROM timelines
ORDER BY period ASC
`

func (q *Queries) GetAllTimelines(ctx context.Context) ([]Timeline, error) {
	rows, err := q.db.QueryContext(ctx, getAllTimelines)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Timeline
	for rows.Next() {
		var i Timeline
		if err := rows.Scan(
			&i.ID,
			&i.Period,
			&i.PdfData,
			&i.IsHighlight,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTimelineByID = `-- name: GetTimelineByID :one
SELECT id, period, pdf_data, is_highlight, created_at, updated_at
FROM timelines
WHERE id = ?
`

func (q *Queries) GetTimelineByID(ctx context.Context, id string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimelineByID, id)
	var i Timeline
	err := row.Scan(
		&i.ID,
		&i.Period,
		&i.PdfData,
		&i.IsHighlight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTimelineByPeriod = `-- name: GetTimelineByPeriod :one
SELECT id, period, pdf_data, is_highlight, created_at, updated_at
FROM timelines
WHERE period = ?
`

func (q *Queries) GetTimelineByPeriod(ctx context.Context, period string) (Timeline, error) {
	row := q.db.QueryRowContext(ctx, getTimelineByPeriod, period)
	var i Timeline
	err := row.Scan(
		&i.ID,
		&i.Period,
		&i.PdfData,
		&i.IsHighlight,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateTimeline = `-- name: UpdateTimeline :execresult
UPDATE timelines
SET period = ?, pdf_data = ?, is_highlight = ?, updated_at = CURRENT_TIMESTAMP
WHERE id = ?
`

type UpdateTimelineParams struct {
	Period      string
	PdfData     []byte
	IsHighlight bool
	ID          string
}

func (q *Queries) UpdateTimeline(ctx context.Context, arg UpdateTimelineParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTimeline,
		arg.Period,
		arg.PdfData,
		arg.IsHighlight,
		arg.ID,
	)
}
